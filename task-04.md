### 1.4.3　针对特殊情况，我们是否还有更好的答案

今天人们对排序算法的改进大多是结合几种排序算法的思想，
形成混合排序算法（Hybrid Sorting Algorithm）。

快速排序和堆排序结合起来的内省排序（Introspective Sort，简称Introsort），
它成为如今大多数标准函数库（STL）中的排序函数使用的算法。

蒂姆排序（Timsort），它是今天Java和安卓（Android）操作系统内部使用的排序算法。

#### 蒂姆排序（Timsort）

蒂姆排序发明人蒂姆·彼得斯（Tim Peters）。
他在2002年发明了一种将两种排序算法的特点相结合
（插入排序节省内存、归并排序节省时间），
最坏时间复杂度控制在O(NlogN)量级，
同时还能够保证排序稳定性这样一举三得的混合排序算法。

大体思路：

一个序列大概率总是有几段有序（从大到小和从小到的）区间，
将较短的有序序列通过插入排序整理成较大的有序块（run），
寻找插入位置使用二分法，
从最短开始合并这些块，
使用了批处理与跳跃式预测等手段。

### 思考题1.4

#### Q1．赛跑问题（GS）。

假定有25名短跑选手比赛争夺前三名，赛场上有五条赛道，一次可以有五名选手同时比赛。比赛并不计时，只看相应的名次。假设选手的发挥是稳定的，也就是说如果约翰比张三跑得快，张三比凯利跑得快，约翰一定比凯利跑得快。最少需要几次比赛才能决出前三名？（在第6章给出了这一问题的解答。（难度系数3颗星））

假设运气好的情况： 按照选手快慢顺序比赛， 只需6次即可得到选手的全序关系。

平均情况下需要NlogN次比较即125次比较， 约25次比赛。

#### Q2．区间排序。

如果有N个区间\[l1,r1\],\[l2,r2\],…,\[lN,rN\]，只要满足下面的条件我们就说这些区间是有序的：存在xi∈\[li,ri\]，其中i=1,2,…,N。

比如，\[1, 4\]、\[2, 3\]和\[1.5, 2.5\]是有序的，因为我们可以从这三个区间中选择1.1、2.1和2.2三个数。同时\[2, 3\]、\[1, 4\]和\[1.5, 2.5\]也是有序的，因为我们可以选择2.1、2.2和2.4。但是\[1, 2\]、\[2.7, 3.5\]和\[1.5, 2.5\]不是有序的。

对于任意一组区间，如何将它们进行排序？（难度系数3颗星)

根据分析， 对于区间\[l1,r1\],\[l2,r2\]， 只要l1 \< r2这两区间即可有序，
根据实数的无穷性， 只要任意前后两区间满足上述关系， 整个区间就是有序的。

因此可以定义比较

> \[l1,r1\] \< \[l1,r2\] \<=\> l1 \< r2

依照此比较法则进行排序即可。

### 附录　为什么排序算法的复杂度不可能小于O(NlogN)

对于N个元素的序列， 共有N！种排列。

通过1次比较可以区分2个序列的大小，
2次比较可以区分4个序列的大小，
N次比较可以区分2^N个序列的大小。

反过来说， N种排列需要logN次比较。

所以对于N个元素的序列需要logN\!次比较。

应用斯特林（Stirling）公式，即lnN\!=NlnN−N+O(lnN)。
因此我们可以得出logN\!=O(NlogN)的结论。

我们估算出的是排序所需要进行比较的次数的下限。
也就是说， 任何排序算法的复杂度不会低于O(NlogN)。
