## 1.4 关于排序的讨论

-----

排序算法是最基础、 使用最频繁的算法。

### 1.4.1 直观的排序算法时间到底浪费在哪里

直观的排序算法复杂度在 *O(n^2)* 。

前提假设： 序列有N个元素，存于一个数组a\[N\]中。

#### 第一种 选择排序（Selection Sort） 冒泡排序

##### 思路

它每一次从序列中挑出一个最大值（最小值），放在序列的最后（最前），
这样重复多次扫描序列后，整个序列就排序完毕，具体做法如下。

步骤一， 从头到尾（从1到N)比较两个相邻元素（a\[i\], a\[i+1\]）。
如果a\[i\] \< a\[i+1\], 不做任何处理，
反之， 交换a\[i\], a\[i+1\]， 到N时N一定为最大值。（冒泡）
或将i记录为当前最大位置， 交换a\[i\], a\[i+1\]。（选择）

这一遍的扫描， 进行了N-1次比较，
少于N-1次的交换（冒泡）1次交换（选择）。

步骤2，我们再从头到倒数第二个元素，即第N−1个元素，重复上述过程。

当我们完成第K遍扫描时， 最后K个元素已经排好序了。
因此，对于有N个元素的数组， 我们只需要扫描N次。

##### 复杂度分析

这样整个算法的复杂度就是(N-1)+(N-2)+···+1=N(N-1)/2 = O(N^2)。

##### 代码实现

C语言 实现选择排序

``` c
int arr[N];
// read arr

for (int i = N - 1; i != 0; --i) {
  int max = 0;
  for (int j = 1; j != i; ++j) {
    if (arr[j] > arr[max]) {
      max = j;
    }
  }
  int tmp t = arr[max];
  arr[max] = arr[i];
  arr[i] = t;
}
```

#### 第二种 插入排序 （Insert Sort）

##### 思路

从前到后（从1到N）扫描元素， 每将它插入到合适的位置。
当扫描完时， 排序也完成了。
具体做法如下。

步骤一，
读取一个元素， 寻找合适的位置插入。
二分法复杂度（logN）， 遍历复杂度（N）。
因为数组是连续的， 插入需要将之后的元素向后移动。
复杂度（N）。

步骤二，
对所有元素依次执行上述操作。

##### 复杂度分析

按上述思路， 复杂度为*O(N^2)*。

##### 代码实现

C语言 实现插入排序

``` c
int arr[N];
// read arr

for (int i = 0; i != N; ++i) {
  int l = 0;
  int r = i;
  while (l != r) {
    int m = (l + r) / 2;
    if (arr[i] < arr[m]) {
      r = m;
    } else {
      l = m + 1;
    }
  }
  int tmp1 = arr[i];
  int tmp2;
  for (int j = l; j != i; ++j) {
    tmp2 = arr[j];
    arr[j] = tmp1;
    tmp1 = tmp2;
  }
}
```

#### 无用功和改进空间

1.  多余的比较， 以上算法对所有元素两两进行了比较，
    但若已知 a \< b, b \< c, 则无需比较a和c。

2.  多余的交换。

### 1.4.2　有效的排序算法效率来自哪里

三种排序算法： 归并排序（Merge Sort）、快速排序（Quick Sort）和堆排序（Heap Sort）。
这三种算法的共同特点是平均时间复杂度均为O(NlogN)。

#### 归并排序

核心思想： 分治递归。

作者： 冯·诺依曼。

##### 思路

递归的将序列分为两分， 至不可分。
将两个有序序列合并为更大的有序序列。

合并。

比较两个序列的首元素， 将较小的放入大序列，
重复过程至两序列都为空。

##### 复杂度分析

将两个序列合并为元素数为N的序列需要至多N次比较， N次移动。

即每个归并过程复杂度为*O(N)*。

对于元素数量为N的序列需要logN次归并。

所以总的复杂度为*O(NlogN)*。

##### 代码实现

C语言 实现归并排序

``` c
int arr[N];
// read arr

int tmp[N];

int *pa = tmp;
int *pb = arr;
for (int i = 1; i < N; i *= 2) {
  int *p1 = pb;
  int *p2 = pb + i;
  while (pb < arr + n - i - i) {
    while ((p1 != pb + i) && (p2 != pb + i + i)) {
      *pa++ = *(*p1 < *p2 ? p1 : p2)++;
    }
    while (p1 != pb + i) {
      *pa++ = *p1++;
    }
    while (p2 != pb + i + i) {
      *pa++ = *p2++;
    }
    pb += i + i;
    p1 = pb;
    p2 = pb + i;
  }

  if (p2 < arr + N) {
    while ((p1 != pb + i) && (p2 != arr + N)) {
      *pa++ = *(*p1 < *p2 ? p1 : p2)++;
    }
    while (p1 != pb + i) {
      *pa++ = *p1++;
    }
    while (p2 != arr + N) {
      *pa++ = *p2++;
    }    
  }
  int *tmp = pa;
  pa = pb;
  pb = tmp;
}

if (pa == tmp)  {
  while (pb != arr + N) {
    *pb++ = *pa++;
  }
}
```

#### 快速排序与堆排序

归并排序有一个问题，就是它需要额外的O(N)大小的存储空间保留中间结果。

英国计算机科学家托尼·霍尔（Tony Hoare）发明了一种比归并排序算法和（后来的）堆排序算法快两三倍的算法，快速排序算法。

快速排序算法只需要O(logN )的额外空间，虽然它不满足就地特征的要求，但是这个空间需求足够小。

快速排序和堆排序存在自己的问题。
快速排序和堆排序本身不具有稳定性。
快速排序还有一个明显的缺点， 那就是虽然它的平均时间复杂度是O(NlogN)，
但是在极端的情况下时间复杂度是O(N2)。
