## 1.4 关于排序的讨论

---

排序算法是最基础、 使用最频繁的算法。

### 1.4.1 直观的排序算法时间到底浪费在哪里

直观的排序算法复杂度在 *O(n^2)* 。

前提假设： 序列有N个元素，存于一个数组a[N]中。

#### 第一种 选择排序（Selection Sort） 冒泡排序

##### 思路
它每一次从序列中挑出一个最大值（最小值），放在序列的最后（最前），
这样重复多次扫描序列后，整个序列就排序完毕，具体做法如下。

步骤一， 从头到尾（从1到N)比较两个相邻元素（a[i], a[i+1]）。
如果a[i] < a[i+1], 不做任何处理，
反之， 交换a[i], a[i+1]， 到N时N一定为最大值。（冒泡）
或将i记录为当前最大位置， 交换a[i], a[i+1]。（选择）

这一遍的扫描， 进行了N-1次比较，
少于N-1次的交换（冒泡）1次交换（选择）。

步骤2，我们再从头到倒数第二个元素，即第N−1个元素，重复上述过程。

当我们完成第K遍扫描时， 最后K个元素已经排好序了。
因此，对于有N个元素的数组， 我们只需要扫描N次。

##### 复杂度分析

这样整个算法的复杂度就是(N-1)+(N-2)+···+1=N(N-1)/2 = O(N^2)。

##### 代码实现

C语言 实现选择排序

``` c
int arr[N];
// read arr

for (int i = N - 1; i != 0; --i) {
  int max = 0;
  for (int j = 1; j != i; ++j) {
    if (arr[j] > arr[max]) {
      max = j;
    }
  }
  int tmp t = arr[max];
  arr[max] = arr[i];
  arr[i] = t;
}
```

#### 第二种 插入排序 （Insert Sort）

##### 思路

从前到后（从1到N）扫描元素， 每将它插入到合适的位置。
当扫描完时， 排序也完成了。
具体做法如下。

步骤一，
读取一个元素， 寻找合适的位置插入。
二分法复杂度（logN）， 遍历复杂度（N）。
因为数组是连续的， 插入需要将之后的元素向后移动。
复杂度（N）。

步骤二，
对所有元素依次执行上述操作。

##### 复杂度分析

按上述思路， 复杂度为*O(N^2)*。

##### 代码实现

C语言 实现插入排序

``` c
int arr[N];
// read arr

for (int i = 0; i != N; ++i) {
  int l = 0;
  int r = i;
  while (l != r) {
    int m = (l + r) / 2;
    if (arr[i] < arr[m]) {
      r = m;
    } else {
      l = m + 1;
    }
  }
  int tmp1 = arr[i];
  int tmp2;
  for (int j = l; j != i; ++j) {
    tmp2 = arr[j];
    arr[j] = tmp1;
    tmp1 = tmp2;
  }
}
```
#### 无用功和改进空间

1. 多余的比较， 以上算法对所有元素两两进行了比较，
但若已知 a < b, b < c, 则无需比较a和c。

2. 多余的交换。

### 1.4.2　有效的排序算法效率来自哪里

三种排序算法： 归并排序（Merge Sort）、快速排序（Quick Sort）和堆排序（Heap Sort）。
这三种算法的共同特点是平均时间复杂度均为O(NlogN)。

#### 归并排序

核心思想： 分治递归。

作者： 冯·诺依曼。

##### 思路

递归的将序列分为两分， 至不可分。
将两个有序序列合并为更大的有序序列。

合并。

比较两个序列的首元素， 将较小的放入大序列，
重复过程至两序列都为空。

##### 复杂度分析

将两个序列合并为元素数为N的序列需要至多N次比较， N次移动。

即每个归并过程复杂度为*O(N)*。

对于元素数量为N的序列需要logN次归并。

所以总的复杂度为*O(NlogN)*。

##### 代码实现

C语言 实现归并排序

``` c
int arr[N];
// read arr

int tmp[N];

int *pa = tmp;
int *pb = arr;
for (int i = 1; i < N; i *= 2) {
  int *p1 = pb;
  int *p2 = pb + i;
  while (pb < arr + n - i - i) {
    while ((p1 != pb + i) && (p2 != pb + i + i)) {
      *pa++ = *(*p1 < *p2 ? p1 : p2)++;
    }
    while (p1 != pb + i) {
      *pa++ = *p1++;
    }
    while (p2 != pb + i + i) {
      *pa++ = *p2++;
    }
    pb += i + i;
    p1 = pb;
    p2 = pb + i;
  }

  if (p2 < arr + N) {
    while ((p1 != pb + i) && (p2 != arr + N)) {
      *pa++ = *(*p1 < *p2 ? p1 : p2)++;
    }
    while (p1 != pb + i) {
      *pa++ = *p1++;
    }
    while (p2 != arr + N) {
      *pa++ = *p2++;
    }    
  }
  int *tmp = pa;
  pa = pb;
  pb = tmp;
}

if (pa == tmp)  {
  while (pb != arr + N) {
    *pb++ = *pa++;
  }
}
```

#### 快速排序与堆排序

归并排序有一个问题，就是它需要额外的O(N)大小的存储空间保留中间结果。

英国计算机科学家托尼·霍尔（Tony Hoare）发明了一种比归并排序算法和（后来的）堆排序算法快两三倍的算法，快速排序算法。

快速排序算法只需要O(logN )的额外空间，虽然它不满足就地特征的要求，但是这个空间需求足够小。

快速排序和堆排序存在自己的问题。
快速排序和堆排序本身不具有稳定性。
快速排序还有一个明显的缺点， 那就是虽然它的平均时间复杂度是O(NlogN)，
但是在极端的情况下时间复杂度是O(N2)。

### 1.4.3　针对特殊情况，我们是否还有更好的答案

今天人们对排序算法的改进大多是结合几种排序算法的思想，
形成混合排序算法（Hybrid Sorting Algorithm）。

快速排序和堆排序结合起来的内省排序（Introspective Sort，简称Introsort），
它成为如今大多数标准函数库（STL）中的排序函数使用的算法。

蒂姆排序（Timsort），它是今天Java和安卓（Android）操作系统内部使用的排序算法。

#### 蒂姆排序（Timsort）

蒂姆排序发明人蒂姆·彼得斯（Tim Peters）。
他在2002年发明了一种将两种排序算法的特点相结合
（插入排序节省内存、归并排序节省时间），
最坏时间复杂度控制在O(NlogN)量级，
同时还能够保证排序稳定性这样一举三得的混合排序算法。

大体思路：

一个序列大概率总是有几段有序（从大到小和从小到的）区间，
将较短的有序序列通过插入排序整理成较大的有序块（run），
寻找插入位置使用二分法，
从最短开始合并这些块，
使用了批处理与跳跃式预测等手段。

### 思考题1.4

#### Q1．赛跑问题（GS）。

假定有25名短跑选手比赛争夺前三名，赛场上有五条赛道，一次可以有五名选手同时比赛。比赛并不计时，只看相应的名次。假设选手的发挥是稳定的，也就是说如果约翰比张三跑得快，张三比凯利跑得快，约翰一定比凯利跑得快。最少需要几次比赛才能决出前三名？（在第6章给出了这一问题的解答。（难度系数3颗星））

假设运气好的情况： 按照选手快慢顺序比赛， 只需6次即可得到选手的全序关系。

平均情况下需要NlogN次比较即125次比较， 约25次比赛。

#### Q2．区间排序。

如果有N个区间[l1,r1],[l2,r2],…,[lN,rN]，只要满足下面的条件我们就说这些区间是有序的：存在xi∈[li,ri]，其中i=1,2,…,N。

比如，[1, 4]、[2, 3]和[1.5, 2.5]是有序的，因为我们可以从这三个区间中选择1.1、2.1和2.2三个数。同时[2, 3]、[1, 4]和[1.5, 2.5]也是有序的，因为我们可以选择2.1、2.2和2.4。但是[1, 2]、[2.7, 3.5]和[1.5, 2.5]不是有序的。

对于任意一组区间，如何将它们进行排序？（难度系数3颗星)

根据分析， 对于区间[l1,r1],[l2,r2]， 只要l1 < r2这两区间即可有序，
根据实数的无穷性， 只要任意前后两区间满足上述关系， 整个区间就是有序的。

因此可以定义比较
> [l1,r1] < [l1,r2] <=> l1 < r2

依照此比较法则进行排序即可。

### 附录　为什么排序算法的复杂度不可能小于O(NlogN)

对于N个元素的序列， 共有N！种排列。

通过1次比较可以区分2个序列的大小，
2次比较可以区分4个序列的大小，
N次比较可以区分2^N个序列的大小。

反过来说， N种排列需要logN次比较。

所以对于N个元素的序列需要logN!次比较。

应用斯特林（Stirling）公式，即lnN!=NlnN−N+O(lnN)。
因此我们可以得出logN!=O(NlogN)的结论。

我们估算出的是排序所需要进行比较的次数的下限。
也就是说， 任何排序算法的复杂度不会低于O(NlogN)。
